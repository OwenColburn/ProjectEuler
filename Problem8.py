"""
7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450

Find the thirteen adjacent digits in the 1000-digit number that have the greatest product. What is the value of this product?

Can't store this number. Way too big. Can store it as a string and just break it up in sections of 13. 
If any number in the string is 0, don't have to check it or the next 13 values.
"""
import time

def chunk_the_num(string, index_var, size):
    new_string = ""
    for i in range(index_var, size):
        new_string += string[i]

    return new_string

def Liker(string):
    product = 1
    for i in string:
        if i == "0":
            break
        product *= int(i)

    return product
    
def do_work(big_int, initial, end):
    count = 1
    product_list = []
    while end <= len(big_int):
        for i in chunk_the_num(big_int, initial, end):
            if i == 0:
                initial += 13
                end += 13
                break
            
        product_list.append(Liker(chunk_the_num(big_int, initial, end)))
        initial += 1
        end += 1
        count += 1

    return max(product_list)
        

def main():
    start_time = time.time()
    big_int = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450"
    initial = 0
    end = initial + 13
    print(do_work(big_int, initial, end))  # This works, trusting the fact that the highest product does not occur from a product of the last 13 numbers.
    print(f"\nThis took {time.time() - start_time} seconds")


main()